# https://github.com/ryanwi/hiringtrends
#    From terms.dic 
import re

TERMS = [
	('.NET',),
	('ActionScript',),
	('ActiveMQ',),
	('Ada',),
	('Agile',),
	('Akka',),
	('Android',),
	('Ansible',),
	('AngularJS', 'Angular', 'Angular.js', 'Angularjs'),
	('Apache',),
	('api',),
	('Apollo',),
	('App Engine','App Engine', 'AppEngine', 'GAE'),
	('AppleScript',),
	('Arc',),
	('Arduino',),
	('Assembly',),
	('Asp',),
	('ASP.NET',),
	('ASP.NET MVC',),
	('Avro',),
	('Awk',),
	('AWS',),
	('Back End',),
	('Backbone', 'Backbone.js', 'Backbonejs'),
	('Bash',),
	('Big Data', 'BigData', 'Big Data'),
	('Boo',),
	('Bootstrap',),
	('C', re.compile(r'\bC(?!\+|#)\b', re.I)),
	('C++',),
	('C#',),
	('Cassandra',),
	('Celery',),
	('Chef',),
	('Clojure',),
	('ClojureScript',),
	('CloudFront',),
	('Closure',),
	('COBOL',),
	('CoffeeScript',),
	('ColdFuison',),
	('Common Lisp',),
	('Compass',),
	('Computer Vision',),
	('CouchBase',),
	('CouchDB',),
	('CSS',),
	('Cucumber',),
	('D3.js', 'D3', 'D3js'),
	('Dart',),
	('Data Mining',),
	('Data Science',),
	('Delphi',),
	('DevOps',),
	('Distributed Systems',),
	('Django',),
	('Docker',),
	('Drupal',),
	('EC2',),
	('Eclipse',),
	('EDI',),
	('Eiffel',),
	('Elasticache',),
	('Elasticsearch', 'Elasticsearch', 'Elastic Search'),
	('Elm',),
	('Emacs',),
	('Embedded Systems',),
	('Ember', 'Ember.js' 'Emberjs'),
	('Erlang',),
	('Express', 'Express.js' 'Expressjs'),
	('F#',),
	('Factor',),
	('Forth',),
	('Fortran',),
	('Front End',),
	('Full Stack',),
	('Gearman',),
	('giraph',),
	('Git',),
	('Golang',),
	('Graphite',),
	('Groovy',),
	('Grunt', 'Grunt.js', 'Gruntjs'),
	('Gulp',),
	('Hadoop',),
	('haproxy',),
	('Haskell',),
	('HaXe',),
	('Heroku',),
	('Hive',),
	('HTML5',),
	('Hudson',),
	('iOS',),
	('JBoss',),
	('Java',),
	('JavaScript',),
	('jenkins',),
	('jQuery',),
	('JSON API',),
	('JSP',),
	('JUnit',),
	('Kafka',),
	('Kestrel',),
	('Kinesis',),
	('Knockout', 'Knockout.js', 'Knockoutjs'),
	('LAMP',),
	('less',),
	('linux',),
	('Lisp',),
	('Logos',),
	('Lua',),
	('Lucene',),
	('Mahout',),
	('Machine Learning',),
	('MapReduce',),
	('MATLAB',),
	('Maven',),
	('memcached', 'memcache'),
	('Mercurial',),
	('Meteor',),
	('Microservices', 'Microservices', 'Microservices', 'Micro Services'),
	('Mongodb', 'mongo', 'mongodb'),
	('MSMQ',),
	('MySQL',),
	('nagios',),
	('neo4j',),
	('nginx',),
	('NLP',),
	('node.js', 'node', 'nodejs'),
	('NServiceBus',),
	('NUnit',),
	('Objective-C', 'Objective-C', 'ObjectiveC', 'Objective C'),
	('Objective-J',),
	('OCaml',),
	('Octave',),
	('Open Source',),
	('OpenCV',),
	('OpenStack',),
	('passion',),
	('passionate',),
	('Pentaho',),
	('Perl',),
	('PhantomJS', 'phantom.js', 'phantomjs'),
	('PHP',),
	('Pig',),
	('Postgresql', 'postgres', 'postgresql',),
	('PowerBuilder',),
	('PowerShell',),
	('Processing',),
	('Prolog',),
	('Protocol Buffers', 'Protocol Buffers', 'Protocol Buffer', 'protobuf'),
	('Puppet',),
	('Python',),
	('R',),
	('RabbitMQ',),
	('Rails',),
	('React', 'react.js', 'reactjs'),
	('Redis',),
	('Resque',),
	('Riak',),
	('REST',),
	('Ruby',),
	('Rust',),
	('Samza',),
	('Sass',),
	('S3',),
	('Scala',),
	('Scrum',),
	('Selenium',),
	('SharePoint',),
	('Shell',),
	('Sidekiq',),
	('Sinatra',),
	('SNS',),
	('SOAP',),
	('Solr',),
	('Spark',),
	('Spring',),
	('SQL',),
	('SQL Server',),
	('SQS',),
	('SSIS',),
	('SSRS',),
	('statistics',),
	('Storm',),
	('Struts',),
	('Tableau',),
	('TDD',),
	('Thrift',),
	('Tomcat',),
	('TypeScript',),
	('Vagrant',),
	('Varnish',),
	('Vi', 'Vim'),
	('Visual Basic',),
	('WCF',),
	('Web Services',),
	('WebForms',),
	('WebSockets',),
	('Windows Phone',),
	('WinForms',),
	('WinRT',),
	('WordPress',),
	('WPF',),
	('XML',),
	('XML Schema',),
	('Yeoman',),
	('zabbix',),
	('ZeroMQ', '0MQ'),
	('zookeeper',),

    # Locations
	('Senior',),

    # Locations
    ('Onsite', re.compile('|'.join([r'\bonsite\b', r'\bno\s+remote\b']), re.I)),
    ('Remote', re.compile('|'.join([r'\b((?<!no\s)remote)']), re.I)),
]

# Compiled term list in the form (TERM, REGEX)
_RE_TERMS = []

_RE_TYPE = type(re.compile(r'', re.I))

def _compile():
    #global _RE_TERMS

    if len(_RE_TERMS) == len(TERMS):
        return _RE_TERMS

    for term in TERMS:
        exprs = []

        if len(term) == 2:
            if type(term[1]) == _RE_TYPE:
                _RE_TERMS.append(term)
                continue

        for word in term:
            pattern = [r'\b']
            for w in word.split():
                pattern.append(re.escape(w))
                pattern.append(r'\s+')
            pattern.pop()
            if word[-1] in '+-#':
                pattern.append(r'($|\s|[.,/;:?\'"\(\)\[\]{}])')
            else:
                pattern.append(r'\b')

            exprs.append(''.join(pattern))
        _RE_TERMS.append((term[0], re.compile('|'.join(exprs), re.I)))

    return _RE_TERMS
        

def match_terms(text):
    """Return a list of terms that this text contains"""

    return [term for term, expr in _compile() if expr.search(text)]
